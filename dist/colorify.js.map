{"version":3,"file":null,"sources":["../src/util.js","../src/imageLoader.js","../src/validator.js","../src/strategies/average.js","../src/strategies/grayscale.js","../src/strategies/index.js","../src/mask.js","../src/painters/canvasUtil.js","../src/painters/blends.js","../src/painters/pixelByPixel.js","../src/painter.js","../src/recolor.js","../src/main.js"],"sourcesContent":["/* @flow */\n\nexport const isDefined = (value) => value != null;\n\nexport const isString = (value) => typeof value === 'string';\n\nexport const isFunction = (value) => typeof value === 'function';\n\nexport const ensureArray = (value) => (Array.isArray(value) ? value : [value]);\n\nexport const isGradient = (color) =>\n  (Array.isArray(color) && !isString(color[0]) && ('value' in color[0]));\n\nexport const ensureColors = (colors) => (isGradient(colors) ? [colors] : ensureArray(colors));\n\nexport const createCanvas = (w, h) => {\n  const canvas = document.createElement('canvas');\n  canvas.width = w;\n  canvas.height = h;\n  return canvas;\n};\n\nconst checkBlendsSupport = () => {\n  const canvas = createCanvas(1, 1);\n  const ctx = canvas.getContext('2d');\n  ctx.globalCompositeOperation = 'screen';\n  return ctx.globalCompositeOperation === 'screen';\n};\n\nexport const hasCanvasBlends = checkBlendsSupport();\n","/* @flow */\n\nconst timeout = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst loadImage = (url, onLoad) => {\n  const image = document.createElement('img');\n  // for now do not throw any error\n  image.onload = image.onerror = onLoad;\n  image.src = url;\n};\n\n// add a timeout: if the image takes longer than ms just return an empty result in the the promise\nconst promisify = (url, ms) =>\n        new Promise((resolve) => Promise.race([\n          loadImage(url, resolve),\n          timeout(ms),\n        ]));\n\nexport default (images, options) => {\n  const toLoad = images\n    .map( (url) => promisify(url, options.timeout) );\n\n  return Promise.all(toLoad);\n};\n","/* @flow */\nimport {isDefined, isString, isFunction} from './util.js';\n\n// Generic function to validate a specific type\nconst validator = (oldOptions, defaults, check, ifPasses) => {\n  return Object.keys(defaults).reduce((options, field) => {\n    options[field] = check(oldOptions[field]) ? ifPasses(oldOptions[field]) : defaults[field];\n    return options;\n  }, {});\n};\n\n// Util functions to manipulate the ensure the original values\nconst castToBoolean = (value) => !!value;\nconst sameValue = (value) => value;\n\n// Public API of the module\nexport default (options, types) => {\n  const booleans = validator(options, types.booleans, isDefined, castToBoolean);\n  const strings = validator(options, types.strings, isString, sameValue);\n  const functions = validator(options, types.functions, isFunction, sameValue);\n\n  // now merge all together\n  return Object.assign({}, booleans, strings, functions, options);\n};\n\nexport const validateStrategy = (options, strategies) => {\n  const value = options.strategy;\n  let strategy = isDefined(value) ? value : 'average';\n  strategy = isString(value) && (value in strategies) ? strategies[value] : value;\n  strategy = isFunction(value) ? value : strategies.average;\n  return strategy;\n};\n","// Based on rgb components average value\nexport default (r, g, b) => Math.floor((r + g + b) / 3);\n","// Based on the human eye perception\nexport default (r, g, b) => Math.floor((0.2125 * r) + (0.7154 * g) + (0.0721 * b));\n","/* @flow */\nimport average from './average';\nimport grayscale from './grayscale';\n\n// Based on luminosity\nconst max = Math.max;\nconst min = Math.min;\n\n// Put them together in an object now\nexport default {\n  average,\n  grayscale,\n  max,\n  min,\n};\n","/* @flow */\n\nimport {ensureArray, createCanvas} from './util';\nimport imageLoader from './imageLoader';\nimport validator, {validateStrategy} from './validator';\n// Some greyscale strategies\nimport strategies from './strategies/index';\n\nconst maskMaker = (image, strategy) => {\n  const canvas = createCanvas(image.width, image.height);\n  const ctx = canvas.getContext('2d');\n\n  // paste the image in the canvas\n  ctx.drawImage(image, 0, 0);\n  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  // grab the raw pixels from the imgData\n  const {data} = imgData;\n\n  // TODO: make a WebWorker do this stuff to avoid blocking the main thread\n  let maxAvg = 0;\n\n  for( let i=0; i < data.length; i += 4) {\n    // do not process transparent pixels (fourth component of the pixel data)\n    if(data[i+3]) {\n      data[i] = data[i+1] = data[i+2] = strategy(data[i], data[1], data[2]);\n      // remember the highest average\n      maxAvg = Math.max(maxAvg, data[i]);\n    }\n  }\n\n  // Now find how far the highest average is from the white\n  const toWhite = 255 - maxAvg;\n\n  // Iterate again and push all the averages by $toWhite\n  for( let i=0; i < data.length; i += 4) {\n    // filter transparent pixels again\n    if(data[i+3]) {\n      // it is an average, so the $i value is fine for the whole pixel\n      const pixel = data[i];\n      data[i] = data[i+1] = data[i+2] = pixel + toWhite;\n    }\n  }\n\n  // now paste the processed image (the mask) in the canvas again\n  ctx.putImageData(imgData, 0, 0);\n\n  // return the mask\n  return canvas;\n};\n\nconst makeMasksFromImages = (images, options) => {\n  return imageLoader(images, options)\n    .then( (loaded) => {\n      return loaded.map( (image) => maskMaker );\n    });\n};\n\n// Mask Maker\nexport default (images, options) => {\n  images = ensureArray(images);\n\n  const defaults = {\n    booleans: {},\n    strings: {},\n    functions: {},\n  };\n\n  const opts = validator(options, defaults);\n  // the mask strategy requires a dedicated validator\n  opts.strategy = validateStrategy(opts, strategies);\n\n  return makeMasksFromImages(images, opts)\n    .then( (masks) => {\n      return images.map((url) => masks[url]);\n    });\n};\n","/* @flow */\n\nimport {isGradient} from '../util';\n\nexport default (context, color, width, height) => {\n  let style;\n  if(isGradient(color)) {\n    // Linear Gradient top to bottom direction\n    style = context.createLinearGradient(width/2, 0, width/2, height);\n    color.forEach( (stop) => {\n      style.addColorStop(stop.value, stop.color);\n    });\n  } else {\n    style = color;\n  }\n  context.fillStyle = style;\n  context.fillRect(0, 0, width, height);\n};\n","/* @flow */\n\nimport recolorLayer from './canvasUtil';\n\nexport default (mask, targets, colors) => {\n  const width = mask.width;\n  const height = mask.height;\n\n  targets.forEach( (target, index) => {\n    const ctx = target.getContext('2d');\n    recolorLayer(ctx, width, height, colors[index]);\n    ctx.globalCompositeOperation = 'multiply';\n    ctx.drawImage(mask, 0, 0);\n    ctx.globalCompositeOperation = 'destination-atop';\n    ctx.drawImage(mask, 0, 0);\n  });\n};\n","/* @flow */\n\nimport recolorLayer from './canvasUtil';\n\nexport default (mask, targets, colors) => {\n  const width = mask.width;\n  const height = mask.height;\n\n  const ctx = mask.getContext('2d');\n  const imgData = ctx.getImageData(0, 0, width, height);\n  const {data} = imgData;\n\n  const contextes = [];\n  const datas = [];\n\n  targets.forEach( (target, index) => {\n    const targetCtx = target.getContext('2d');\n    // draw a the first layer with the color we want to apply\n    recolorLayer(targetCtx, width, height, colors[index]);\n    // dump the data of the recolored image\n    const targetData = targetCtx.getImageData(0, 0, width, height);\n    // now save the references to be processed\n    contextes.push(targetCtx);\n    datas.push(targetData);\n  });\n\n  const colorPixel = (grey, alpha) => {\n    // return a function\n    return (data, i) => {\n      data[i] = Math.floor(grey * data[i]);\n      data[i+1] = Math.floor(grey * data[i+1]);\n      data[i+2] = Math.floor(grey * data[i+2]);\n      // preserve the original mask alpha\n      data[i+3] = alpha;\n    };\n  };\n\n  // iterate throught the mask raw data\n  for( let i=0; i < data.length; i +=4 ) {\n    // skip transparent pixels\n    if(data[i+3]) {\n      datas.forEach( (imgData) => {\n        const pixelPainter = colorPixel(data[i]/255, data[i+3]);\n        pixelPainter(imgData.data, i);\n      });\n    }\n  }\n\n  // now paste the final image in the relative contextes\n  contextes.forEach( (context, index) => {\n    context.putImageData(data[index], 0, 0);\n  });\n};\n","/* @flow */\nimport {isGradient, ensureArray, createCanvas, hasCanvasBlends} from './util';\nimport validator from './validator';\nimport recolorWithBlends from './painters/blends';\nimport recolorWithPixelManipulation from './painters/pixelByPixel';\n\nconst recolorImage = (mask, colors) => {\n  const width = mask.width;\n  const height = mask.height;\n\n  // create a new canvas for each new colored version of the image\n  const targets = colors.map( () => createCanvas(width, height) );\n\n  // Check the support for advanced canvas features and use the appropriate processor\n  const processor = hasCanvasBlends ? recolorWithBlends : recolorWithPixelManipulation;\n  processor(mask, targets, colors);\n\n  return targets.map( (canvas) => canvas.toDataURL());\n};\n\nexport default (mask, colors, options) => {\n  const defaults = {\n    booleans: {},\n    strings: {},\n    functions: {},\n  };\n\n  options = validator(options, defaults);\n  colors = isGradient(colors) ? [colors] : ensureArray(colors);\n\n  return recolorImage(mask, colors);\n};\n","/* @flow */\n\nimport createMasks from './mask.js';\nimport colorize from './painter.js';\nimport imageLoader from './imageLoader.js';\n\nexport default (definitions, options) => {\n  // split image data from colour data\n  const images = definitions.map((definition) => definition.url);\n  return imageLoader(images)\n    .then((loaded) => createMasks(loaded, options))\n    .then((masks) => colorize(masks, options));\n};\n","/* @flow */\n\nimport {ensureArray, ensureColors} from './util';\nimport createMask from './mask';\nimport recolorMask from './recolor';\n\nexport default (images, colors, options) => {\n  images = ensureArray(images);\n  colors = ensureColors(colors);\n\n  return createMask(images, options)\n    .then( (masks) => masks.reduce( (loaded, mask, index) => {\n        const url = images[index];\n\n        if(!loaded.has(url)) {\n          loaded.set( url, recolorMask(mask, colors, options) );\n        }\n\n        return loaded;\n      }, new Map())\n    )\n    .then( (recolored) => images.map( recolored.get ) );\n};\n"],"names":["isDefined","value","isString","isFunction","ensureArray","Array","isArray","isGradient","color","ensureColors","colors","createCanvas","w","h","canvas","document","createElement","width","height","checkBlendsSupport","ctx","getContext","globalCompositeOperation","hasCanvasBlends","timeout","ms","Promise","resolve","setTimeout","loadImage","url","onLoad","image","onload","onerror","src","promisify","race","images","options","toLoad","map","all","validator","oldOptions","defaults","check","ifPasses","Object","keys","reduce","field","castToBoolean","sameValue","types","booleans","strings","functions","assign","validateStrategy","strategies","strategy","average","r","g","b","Math","floor","max","min","maskMaker","drawImage","imgData","getImageData","data","maxAvg","i","length","toWhite","pixel","putImageData","makeMasksFromImages","imageLoader","then","loaded","opts","masks","context","style","createLinearGradient","forEach","stop","addColorStop","fillStyle","fillRect","mask","targets","target","index","contextes","datas","targetCtx","targetData","push","colorPixel","grey","alpha","pixelPainter","recolorImage","processor","recolorWithBlends","recolorWithPixelManipulation","toDataURL","definitions","definition","createMasks","colorize","createMask","has","set","recolorMask","Map","recolored","get"],"mappings":"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"}